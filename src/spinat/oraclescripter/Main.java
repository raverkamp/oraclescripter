package spinat.oraclescripter;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Locale;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;
import oracle.jdbc.OracleConnection;

public class Main {

    private static void abort(String msg) {
        System.err.println("abort scripting:");
        System.err.println(msg);
        System.exit(1);
    }

    // rezurn the list of objects to script, this list is sorted!
    private static ArrayList<DBObject> getDBObjects(Connection c, String owner, boolean useDBAViews, java.util.Properties p) throws SQLException {
        String objs = Helper.getProp(p, "objects", null);
        String obj_where = Helper.getProp(p, "object-where", null);
        String obj_file = Helper.getProp(p, "object-file", null);

        if ((objs == null ? 0 : 1) + (obj_where == null ? 0 : 1)
                + (obj_file == null ? 0 : 1) != 1) {
            throw new RuntimeException("either property \"objects\", \"object-where\""
                    + " or \"object-file\" must be given");
        }
        String where_clause;
        if (objs != null) {
            ArrayList<String> a = Helper.objectsToArrayList(objs);
            where_clause = "object_name in " + Helper.arrayToInList(a);
        } else if (obj_where != null) {
            where_clause = obj_where;
        } else {
            ArrayList<String> a = Helper.objectsFromFile(obj_file);
            where_clause = "object_name in " + Helper.arrayToInList(a);
        }
        String objectView = useDBAViews ? "dba_objects" : "all_objects";
        String typeView = useDBAViews ? "dba_types" : "all_types";
        try (PreparedStatement stm = c.prepareStatement("select distinct object_name,object_type\n"
                + "from " + objectView + "\n"
                + "where object_type in ('PACKAGE','PROCEDURE',\n"
                + "'FUNCTION','VIEW','TRIGGER','TYPE')\n"
                + " and owner = ? "
                // get rid of types generated by PL/SQL for pipelined table functions
                + " and ( object_type <>'TYPE' or object_name in (select type_name from " + typeView + " where owner=?)) "
                + " and (" + where_clause + " ) "
                // triggers are last, views are next to last, this is important
                // for running the script with sqlplus, you can only create an
                // instead of trigger on a viwe if the view exists
                + " order by case object_type when 'TRIGGER' then 'Z' else object_type end,object_name ")) {
            stm.setString(1, owner);
            stm.setString(2, owner);
            try (ResultSet rs = stm.executeQuery()) {
                ArrayList<DBObject> res = new ArrayList<>();
                while (rs.next()) {
                    String name = rs.getString(1);
                    String type = rs.getString(2);
                    res.add(new DBObject(type, name));
                }
                return res;
            }
        }
    }

    private static void writeTextFile(Path file, String txt, String encoding) throws IOException {
        if (Files.exists(file)) {
            throw new RuntimeException("file " + file + " already exists");
        }
        String s = Helper.stringUnixLineEnd(txt);
        if (encoding.equals("german-ascii")) {
            encoding = "ascii";
            s = s.replace("\u00C4", "Ae").replace("\u00D6", "Oe").replace("\u00DC", "Ue")
                    .replace("\u00E4", "ae").replace("\u00F6", "oe").replace("\u00FC", "ue")
                    .replace("\u00DF", "ss");
        }

        try (PrintStream ps = new PrintStream(file.toFile(), encoding)) {
            ps.append(s);
        }
    }

    static Map<String, String> suffixMap = Helper.mkStringMap(
            new String[]{
                "package_body", "pkb",
                "package_spec", "pks",
                "package", "pkg",
                "type_body", "tpb",
                "type_spec", "tps",
                "type", "typ",
                "procedure", "prc",
                "function", "fun",
                "view", "vw",
                "trigger", "trg"});

    private static Path saveObject(Path baseDir, java.util.Properties props,
            String objectType, String objectName, String src)
            throws IOException {
        String encoding = Helper.getProp(props, "encoding", "UTF-8");
        String type;
        if (objectType.equals("PACKAGE BODY")) {
            type = "package_body";
        } else if (objectType.equals("PACKAGE SPEC")) {
            type = "package_spec";
        } else if (objectType.equals("TYPE BODY")) {
            type = "type_body";
        } else if (objectType.equals("TYPE SPEC")) {
            type = "type_spec";
        } else {
            type = objectType.toLowerCase();
        }
        String dir = props.getProperty("dir." + type, "");
        String suffix = props.getProperty("suffix." + type, suffixMap.get(type));
        String filename = objectName.toLowerCase() + "." + suffix;
        final Path fileRelative;
        if (dir.equals("")) {
            fileRelative = Paths.get(filename);
        } else {
            fileRelative = Paths.get(dir, filename);
        }
        {
            final Path realBaseDir;
            if (!dir.equals("")) {
                realBaseDir = baseDir.resolve(dir);
            } else {
                realBaseDir = baseDir;
            }
            if (!Files.exists(realBaseDir)) {
                Files.createDirectories(realBaseDir);
            }
        }

        Path file = baseDir.resolve(fileRelative);
        writeTextFile(file, src, encoding);
        return file;
    }

    static void prepareBaseDir(Path p, boolean doGit) throws IOException {
        if (!Files.exists(p)) {
            Path pd = Files.createDirectories(p);
            if (doGit) {
                GitHelper.createRepoInDir(pd.toFile());
            }
        } else {
            if (!Files.isDirectory(p)) {
                throw new RuntimeException("this is not a directory: " + p);
            }
            if (doGit) {
                GitHelper.checkForRepoInDir(p.toFile());
            }
        }
        Helper.deleteDirectoryContents(p);
    }

    static String appendSlash(String s) {
        if (s.endsWith("\n")) {
            return s + "/\n";
        } else {
            return s + "\n/\n";
        }
    }

    static Path writePrivateSynonyms(OracleConnection con, Path baseDir, String encoding, boolean useDBAViews, String owner)
            throws IOException, SQLException {
        Path synPath = baseDir.resolve("private-synonyms.sql");
        StringBuilder b = new StringBuilder();
        String synonymView;
        if (useDBAViews) {
            synonymView = "dba_synonyms";
        } else {
            synonymView = "all_synonyms";
        }
        try (PreparedStatement stm = con.prepareStatement("select synonym_name,table_owner,table_name,db_link from " + synonymView + " where owner=? order by synonym_name")) {
            stm.setString(1, owner);
            try (ResultSet rs = stm.executeQuery()) {
                while (rs.next()) {
                    String sname = rs.getString(1);
                    String schema = rs.getString(2);
                    String obj = rs.getString(3);
                    String s = "create or replace synonym "
                            + Helper.maybeOracleQuote(sname) + " for "
                            + Helper.maybeOracleQuote(schema) + "."
                            + Helper.maybeOracleQuote(obj);
                    String li = rs.getString(4);
                    if (li != null) {
                        s = s + "@" + li;
                    }
                    s = s + ";";
                    b.append(s);
                    b.append("\n");
                }
            }
        }
        writeTextFile(synPath, b.toString(), encoding);
        return synPath;
    }

    static Path writeSequences(Connection con, Path baseDir, String encoding, boolean useDBAViews, String owner)
            throws IOException, SQLException {
        Path synPath = baseDir.resolve("sequences.sql");
        StringBuilder b = new StringBuilder();
        String sequenceView;
        if (useDBAViews) {
            sequenceView = "dba_sequences";
        } else {
            sequenceView = "all_sequences";
        }
        String query = "select sequence_name,increment_by from " + sequenceView + " where sequence_owner=? order by sequence_name";
        try (PreparedStatement stm = con.prepareStatement(query)) {
            stm.setString(1, owner);
            try (ResultSet rs = stm.executeQuery()) {
                while (rs.next()) {
                    String s = "create sequence " + Helper.maybeOracleQuote(rs.getString(1));
                    String incby = rs.getString(2);
                    if (!incby.equals("1")) {
                        s = s + " increment by " + incby;
                    }
                    s = s + ";";
                    b.append(s);
                    b.append("\n");
                }
            }
            writeTextFile(synPath, b.toString(), encoding);
            return synPath;
        }
    }

    static boolean hasDBAViews(Connection c) throws SQLException {
        // if we have access to dba_objects we assume that we have access to the rest as well
        // we get an exception if we do not have access
        //  but we check that the exception has nothing to do with the connection
        try (PreparedStatement stm = c.prepareStatement("select 1 as a from dba_objects where 1=2");
                ResultSet rs = stm.executeQuery()) {
            return true;
        } catch (SQLException ex) {

            if (c.isValid(5)) {
                return false;
            } else {
                throw ex;
            }
        }
    }

    static boolean userExists(Connection c, String owner) throws SQLException {
        try (PreparedStatement stm = c.prepareStatement("select username from dba_users where username=?")) {
            stm.setString(1, owner);
            try (ResultSet rs = stm.executeQuery()) {
                if (rs.next() && rs.getString(1).equals(owner)) {
                    return true;
                } else {
                    return false;
                }
            }
        }
    }

    static OracleConnection getConnection(String desc) throws ParseException {
        spinat.oraclelogin.OraConnectionDesc cd = spinat.oraclelogin.OraConnectionDesc.fromString(desc);
        if (!cd.hasPwd()) {
            if (System.console() == null) {
                abort("No password was given and there is no input console to enter it.");
            }
            char[] pw = System.console().readPassword("Password for " + cd.display() + ":");
            cd.setPwd(new String(pw));
        }
        OracleConnection con = null;
        try {
            return cd.getConnection();
        } catch (SQLException e) {
            abort("cannot get connection described by " + desc
                    + "\n" + e.toString());
            // abort aborts, so never reached
            throw new Error("");
        }
    }

    private static java.util.Properties loadProperties(String fileName) throws IOException {
        java.util.Properties props = new java.util.Properties();
        {
            Path p = Paths.get(fileName);
            if (Files.isReadable(p)) {
                try (FileInputStream fi = new FileInputStream(fileName)) {
                    props.load(fi);
                }
            } else {
                abort("cannot read property file: " + p);
            }
        }
        return props;
    }

    public static void main(String[] args) throws SQLException, IOException, ParseException {
        try {
            java.sql.DriverManager.registerDriver(new oracle.jdbc.driver.OracleDriver());
        } catch (Exception e) {
            abort("can not initialize Oracle JDBC\n" + e.toString());
        }

        if (args.length < 1) {
            abort("Expecting at least one Argument: the name of the property file,\n"
                    + "the optional second argument is a connection description");
        }
        Path propertiesPath = Paths.get(args[0]).toAbsolutePath();
        java.util.Properties props = loadProperties(propertiesPath.toString());
        
        Path relBaseDir = Paths.get(Helper.getProp(props, "directory"));
        Path baseDir = propertiesPath.getParent().resolve(relBaseDir);
        
        String connectionDesc;
        if (args.length == 2) {
            connectionDesc = args[1];
        } else {
            connectionDesc = Helper.getProp(props, "connection", null);
        }

        String encoding = Helper.getProp(props, "encoding", "UTF-8");
        
        
        
        boolean usegit = Helper.getPropBool(props, "usegit", false);
        prepareBaseDir(baseDir, usegit);
        String schemas = Helper.getProp(props, "schemas", "");

        if (!schemas.equals("")) {
            String[] schema_list = schemas.split(",");

            if (connectionDesc != null) {
                OracleConnection c = getConnection(connectionDesc);
                if (!hasDBAViews(c)) {
                    abort("if multiple schemas, one connection given, but without access to dba views");
                }
                for (String schema : schema_list) {
                    if (!userExists(c, schema.trim().toUpperCase(Locale.ROOT))) {
                        abort("the user " + schema.trim() + " does not exist.");
                    }
                }
                for (int i = 0; i < schema_list.length; i++) {
                    String schema = schema_list[i].trim();
                    String owner = schema.toUpperCase(Locale.ROOT);
                    Path schemaBaseDir = baseDir.resolve(schema.toLowerCase());
                    Path pd = Files.createDirectories(schemaBaseDir);
                    System.out.println("--------" + schema + "--------");
                    exportToDir(schemaBaseDir, c, owner, true, props, encoding);
                }
                c.close();
            } else {
                // in the first step make sure we get all connections
                // only then start scription
                // note that getConnection might ask for a password
                OracleConnection[] connection_list = new OracleConnection[schema_list.length];
                for (int i = 0; i < schema_list.length; i++) {
                    String schema = schema_list[i].trim();
                    String desc = Helper.getProp(props, schema + ".connection");
                    OracleConnection con = getConnection(desc);
                    connection_list[i] = con;
                }
                for (int i = 0; i < schema_list.length; i++) {
                    String schema = schema_list[i].trim();
                    String owner = schema.toUpperCase(Locale.ROOT);
                    Path schemaBaseDir = baseDir.resolve(schema.toLowerCase());
                    Path pd = Files.createDirectories(schemaBaseDir);
                    System.out.println("--------" + schema + "--------");
                    exportToDir(schemaBaseDir, connection_list[i], owner, false, props, encoding);
                    connection_list[i].close();
                }
            }
        } else {

            // we have the configuration properties and the diretory they are in
            if (connectionDesc == null) {
                abort("no connection descriptor found");
            }
            try (OracleConnection con = getConnection(connectionDesc)) {
                exportToDir(baseDir, con, con.getUserName(), false, props, encoding);
            }
        }
        if (usegit) {
            System.out.println("-------------------");
            GitHelper.AddVersion(baseDir.toFile(), "das war es");
        }
    }

    static void exportToDir(
            Path baseDir,
            OracleConnection con,
            String owner,
            boolean useDBAViews,
            java.util.Properties props,
            String encoding) throws SQLException, IOException {
        // now get the objects
        ArrayList<DBObject> objects = getDBObjects(con, owner, useDBAViews, props);
        ArrayList<Path> allobjects = new ArrayList<>();
        boolean combine_spec_body = Helper.getPropBool(props, "combine_spec_and_body", false);
        SourceCodeGetter scg = new SourceCodeGetter(con, owner, useDBAViews);
        scg.load(objects);
        for (DBObject dbo : objects) {
            System.out.println("doing " + dbo.type + " " + dbo.name);
            if (dbo.type.equals("PACKAGE")) {
                if (combine_spec_body) {
                    String s = scg.getCode("PACKAGE", dbo.name);
                    String b = scg.getCode("PACKAGE BODY", dbo.name);
                    if (b != null) {
                        allobjects.add(saveObject(baseDir, props, "PACKAGE", dbo.name, appendSlash(s) + appendSlash(b)));
                    } else {
                        allobjects.add(saveObject(baseDir, props, "PACKAGE", dbo.name, appendSlash(s)));
                    }
                } else {
                    String s = scg.getCode("PACKAGE", dbo.name);
                    allobjects.add(saveObject(baseDir, props, "PACKAGE SPEC", dbo.name, appendSlash(s)));
                    String b = scg.getCode("PACKAGE BODY", dbo.name);
                    if (b != null) {
                        allobjects.add(saveObject(baseDir, props, "PACKAGE BODY", dbo.name, appendSlash(b)));
                    }
                }
            } else if (dbo.type.equals("TYPE")) {
                if (combine_spec_body) {
                    String s = scg.getCode("TYPE", dbo.name);
                    String b = scg.getCode("TYPE BODY", dbo.name);
                    if (b != null) {
                        allobjects.add(saveObject(baseDir, props, "TYPE", dbo.name, appendSlash(s) + appendSlash(b)));
                    } else {
                        allobjects.add(saveObject(baseDir, props, "TYPE", dbo.name, appendSlash(s)));
                    }
                } else {
                    String s = scg.getCode("TYPE", dbo.name);
                    allobjects.add(saveObject(baseDir, props, "TYPE SPEC", dbo.name, appendSlash(s)));
                    String b = scg.getCode("TYPE BODY", dbo.name);
                    if (b != null) {
                        allobjects.add(saveObject(baseDir, props, "TYPE BODY", dbo.name, appendSlash(b)));
                    }
                }
            } else {
                String s = scg.getCode(dbo.type, dbo.name);
                allobjects.add(saveObject(baseDir, props, dbo.type, dbo.name, appendSlash(s)));
            }
        }
        boolean private_synonyms = Helper.getPropBool(props, "private-synonyms", true);
        if (private_synonyms) {
            Path p = writePrivateSynonyms(con, baseDir, encoding, useDBAViews, owner);
            allobjects.add(0, p);
        }
        boolean sequences = Helper.getPropBool(props, "sequences", true);
        if (sequences) {
            Path p = writeSequences(con, baseDir, encoding, useDBAViews, owner);
            allobjects.add(0, p);
        }

        Path allObjectsPath = baseDir.resolve("all-objects.sql");
        StringBuilder b = new StringBuilder();

        for (Path p : allobjects) {
            Path rel = baseDir.relativize(p);
            b.append("@@").append(rel.toString());
            b.append("\n");
        }

        writeTextFile(allObjectsPath, b.toString(), encoding);
    }

}
